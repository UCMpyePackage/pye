% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AUC_based_functions_with_covariates.R
\name{AucPR_compute_cv}
\alias{AucPR_compute_cv}
\title{AucPR_compute_cv}
\usage{
AucPR_compute_cv(
  n_folds,
  df,
  X = names(df[, !(names(df) \%in\% c(y, C))]),
  y = "y",
  C = NULL,
  lambda,
  tau = 0,
  regressors_betas = NULL,
  trace = 1,
  model_type = c("AucPR_L1", "AucPR_EN"),
  seed = 1,
  used_cores,
  scaling = FALSE,
  c_function_of_covariates = FALSE,
  simultaneous = FALSE,
  measure_to_select_lambda = "ccr",
  alpha_g = 0.5,
  penalty_g = "L1",
  kernel_g = "gaussian",
  a1_g = 3.7,
  a2_g = 3,
  trend_g = "monotone",
  gamma_start_input = NULL,
  gamma_start_default = "zeros",
  regressors_gammas = NULL,
  max_iter_g = 10000,
  delta_g = 1e-05,
  max_alpha_g = 10000,
  stepsizeShrink_g = 0.8,
  min_alpha_g = 1e-12,
  convergence_error_g = 1e-07,
  run_aauc = FALSE
)
}
\arguments{
\item{n_folds}{number of fold of the cross validation}

\item{df}{the input dataset}

\item{X}{regressors to consider in the estimation. It can be of type
dataframe, containing also the same name of the regressors included in df,
of just a vector of character. Default is all not present in y and C}

\item{y}{the target variable. It can be only binomial 0,1. It can be of type
dataframe, containing also the same name of the same target variable included
in df, or just a character. Default is "y".}

\item{C}{covariate variables. It can be of type dataframe, containing the
same covariates included in df, or just a vector of character. Default is NULL}

\item{lambda}{the penalization parameter of the regressors X}

\item{tau}{the penalization parameter of the covariates C, in covYI. Default 0,
i.e. no penalization term}

\item{regressors_betas}{a vector containing the real betas (if known). Default
is NULL, i.e. we do not know the real regressors}

\item{trace}{2:visualize all the steps, 1:visualize just the result,
0:visualize nothing. Default is 1}

\item{model_type}{model to use in the estimation. The user can choose
among "AucPR_L1","AucPR_EN".}

\item{seed}{fix the seed. Default is 1}

\item{used_cores}{number of core used for the parallelization of the
process. if equal to 1, then no parallelization is adopted. Default is 1.}

\item{scaling}{if TRUE, the dataset is scaled. FALSE otherwise, Default is
FALSE.}

\item{c_function_of_covariates}{if TRUE, covYI is used to estimate the
cut-off point as function of the convariate information. If FALSE, the
covariate information is ignored. Default is FALSE}

\item{simultaneous}{in case of c_function_of_covariates=TRUE, it defines if
gammas needs to be estimated simultaneously or as a second step with respect
of betas. Default is FALSE, i.e. not simultaneously}

\item{measure_to_select_lambda}{the measure used to select lambda if
simultaneous=FALSE, i.e. when the cross-validation proecess select fist
lambda and then tau. Default is "ccr", i.e. the correct classification rate}

\item{alpha_g}{parameter for the Elastic-Net penalization term in covYI.
Default is 0.5}

\item{penalty_g}{the considered penalty of covYI. To be chosen among L12, L1,
EN, SCAD and MCP. Default if "L1"}

\item{kernel_g}{the kernel type to use for the estimation of the density
function (tested only for "gaussian") in covYI.  Default is "gaussian"}

\item{a1_g}{parameter for the SCAD and MCP penalization term in covYI. Default is 3.7}

\item{a2_g}{parameter for the MCP penalization term in covYI. Default is 3.0}

\item{trend_g}{for covYI. If "monotone", mmAPG is used, if "nonmonotone",
mnmAPG is used. Default is "monotone"}

\item{gamma_start_input}{vector of a specific starting point for gammas.
Default is NULL, i.e. no input vector}

\item{gamma_start_default}{set the default starting point of gamma.
If "zeros", it starts with all zero values, if "corr" it starts with the
value of the correlation of every regressor with the target variable.}

\item{regressors_gammas}{a vector containing the real gammas (if known).
Default is NULL}

\item{max_iter_g}{maximum number of iterations in the algorithms mmAPG and
mnmAPG in covYI. Default is 10000}

\item{delta_g}{parameter for the convergence condition of the optimization
algorithm of covYI. Default is 1e-5}

\item{max_alpha_g}{maximum value of the step-parameter alpha in covYI.
Default is 100}

\item{stepsizeShrink_g}{parameter to adjust the step-size in the backtracking
line-search, in the optimization of covYI. Taking values between 0 and 1,
the closer to 1, the more accurate the estimation will be, the longer it
will take and viceversa. Default is 0.8}

\item{min_alpha_g}{minimum value of the step-parameter alpha in covYI.
Default is 1e-12}

\item{convergence_error_g}{in covYI, it is error to accept for considering the algorithm
converged. Default is 1e-5}

\item{run_aauc}{if FALSE the aAUC and aYI are not computed, to save stimation
time if not requested. Default is FALSE}
}
\value{
a list containing the optimal values of lambda (and possibly tau) to
estimate betas (and possibly gammas) and the value of the main accuracy measure
for all the folds.
}
\description{
function to perform the cross-validation to select the best
value of lambda (and possibly tau) for the estimation of betas and c (and
possibly gammas) using AucPR (and possibly covYI).
}
\examples{
library(pye)
cols <- 2000
cols_cov <- 20
seed=1
simMicroarrayData_cov02_dim50_covariates <- create_sample_with_covariates(
		rows_train=50, cols=cols, cols_cov=cols_cov, covar=0.2, seed=seed)
df <- simMicroarrayData_cov02_dim50_covariates$train_df_scaled
X <- simMicroarrayData_cov02_dim50_covariates$X
y <- simMicroarrayData_cov02_dim50_covariates$y
C <- simMicroarrayData_cov02_dim50_covariates$C
regressors_betas<-simMicroarrayData_cov02_dim50_covariates$nregressors
regressors_gammas<-simMicroarrayData_cov02_dim50_covariates$ncovariates
penalty <- "SCAD"
c <- 0
prox_penalty = get(paste0("proximal_operator_", penalty))
trend = "monotone" #or "nonmonotone"
pye_starting_point = "zeros" #c("zeros", "corr")
alpha = 0.5
c_zero_fixed <- FALSE
c_function_of_covariates <- TRUE
used_cores <- 1
used_penalty_pye <- c("L1", "MCP") #c("L12", "L1", "EN", "SCAD", "MCP")
max_iter <- 10
n_folds <- 5
simultaneous <- FALSE #with false, covYI is applied as a second step, once we
#have already estimated lambda

#measure_to_select_lambda (in case simultaneous = FALSE, this is the measure
#we  use to select lambda_star)
measure_to_select_lambda = "ccr" #c("auc", "aauc", "aYI", "ccr", "yi", "gm")

if (c_function_of_covariates==TRUE){
  used_penalty_covYI = c("L1") #c("L12", "L1", "EN", "SCAD", "MCP")
} else {
  used_penalty_covYI = "NO"
}

#see printed warnings:
options(warn=1)

for (p in used_penalty_covYI){

  #competitors AUC based
  AUC_based_models = "AucPR_L1" #c("AucPR_L1", "AucPR_EN")

  for (m in AUC_based_models){

    name <- paste0("param_estimate_", m, "_", p)

    #wrapper of the function
    wrapper_lambda <- function(lambda){
      return(AucPR_estimation(df=df, X=X, y=y, model_type=m, lambda=lambda,
     	regressors_betas=regressors_betas, trace=1))
    }
    #lambda to max and min
    lambda_max <- calibrate_lambda_max (function_to_run=wrapper_lambda,
    var_to_check="betas_hat", lambda_start = 5)
    lambda_min <- calibrate_lambda_min (function_to_run=wrapper_lambda,
    	var_to_check="betas_hat", lambda_start = 0.0001, max_var = 100)

    cat("\n Method:", m, "; lambda_max=", lambda_max, "; lambda_min=", lambda_min,
    "\n")

    #create a suited lambda
    lambda = create_lambda(n=3, lmax=lambda_max, lmin=lambda_min)
    lambda = as.numeric(formatC(lambda, format = "e", digits = 9))

    if(c_function_of_covariates == TRUE){
      #wrapper of the function for tau
      lambda_star <- (lambda_max+lambda_min)/2
      z_hat <- AucPR_estimation(df=df, X=X, y=y, model_type=m, lambda=lambda_star,
      	regressors_betas=regressors_betas, trace=1)$z_hat$z_hat
      wrapper_tau <- function(tau){
        return(covYI_KS_estimation(df=cbind(df, z_hat=z_hat), z="z_hat", y=y, C=C,
        	tau=tau, gamma_start_input=NULL, gamma_start_default=pye_starting_point,
        	trace=2, alpha=alpha, penalty=p, regressors_gammas=regressors_gammas,
        	trend=trend, max_iter=max_iter)) #max_iter=50
      }

      #tau to max and min
      tau_max <- calibrate_lambda_max (function_to_run=wrapper_tau,
      	var_to_check=paste0("gammas_hat_",p), lambda_start = 5, n_min_var=1)
      tau_min <- calibrate_lambda_min (function_to_run=wrapper_tau,
      	var_to_check=paste0("gammas_hat_",p), lambda_start = 0.0001,
		max_var=(length(C)-1))

      cat("\n tau_max=", tau_max, "; tau_min=", tau_min, "\n")

      #create a suited tau
      tau <- create_lambda(n=3, lmax=tau_max, lmin=tau_min)
      tau <- as.numeric(formatC(tau, format = "e", digits = 9))
    }

    #start cross-validation
    assign(name, AucPR_compute_cv(model_type=m, trace=1, n_folds=n_folds,
                                 df=df, X=X, y=y, C=C, lambda=lambda, tau=tau,
                                 used_cores=used_cores,
                                 regressors_betas=regressors_betas,
                                 regressors_gammas=regressors_gammas,
                                 c_function_of_covariates=c_function_of_covariates,
                                 simultaneous=simultaneous,
                                 measure_to_select_lambda=measure_to_select_lambda,
                                 penalty_g=p, max_iter_g=max_iter, run_aauc=FALSE))

    #take the best lambda per measures (if we have the same measure for diff
    #lambdas, we take the one associated to less betas)
    assign(paste0("lambda_hat_", m , "_", p ,"_yi"), get(name)$lambda_hat_yi)
    assign(paste0("lambda_hat_", m , "_", p ,"_auc"), get(name)$lambda_hat_auc)
    assign(paste0("lambda_hat_", m , "_", p ,"_aauc"), get(name)$lambda_hat_aauc)
    assign(paste0("lambda_hat_", m , "_", p ,"_aYI"), get(name)$lambda_hat_aYI)
    assign(paste0("lambda_hat_", m , "_", p ,"_ccr"), get(name)$lambda_hat_ccr)
    assign(paste0("lambda_hat_", m , "_", p ,"_gm"), get(name)$lambda_hat_gm)

    assign(paste0("tau_hat_", m , "_", p ,"_yi"), get(name)$tau_hat_yi)
    assign(paste0("tau_hat_", m , "_", p ,"_auc"), get(name)$tau_hat_auc)
    assign(paste0("tau_hat_", m , "_", p ,"_aauc"), get(name)$tau_hat_aauc)
    assign(paste0("tau_hat_", m , "_", p ,"_aYI"), get(name)$tau_hat_aYI)
    assign(paste0("tau_hat_", m , "_", p ,"_ccr"), get(name)$tau_hat_ccr)
    assign(paste0("tau_hat_", m , "_", p ,"_gm"), get(name)$tau_hat_gm)
  }
}

}
